# **SHELL**

## 1) ЗНАКОМСТВО СО ЗВЕРЕМ

### **(?)** Чтобы использовать кого-то, нужно знать его в лицо. Так что же такое SHELL?

Это командная оболочка в любых unix-подобных системах, к которым относится и GNU/Linux, является обычной программой, запускаемой как в текстовой консоли, так и в графической среде – в окне эмулятора терминала, доступного в любой Linux-системе.

Задачa SHELL: принять строку (или строки) ввода, произвести их синтаксический анализ и на основе результатов этого анализа отреагировать соответствующим образом – выполнить команду, запустить программу, вывести диагностическое сообщение и т.п.

### **(?)** Теперь мы знаем этого "зверя", но какие у него функции?

   **К функциям SHELL относятся:**
              
1)Взаимодействие с пользователем (редактирование командной строки, история команд и т.д.).

2)Обработка (расширение) шаблонов имен ("*", "?" и т.д.).

3)Перенаправление ввода/вывода команд.

4)Управление заданиями. 

### **(?)** А есть ли приемущества в использовании именно  командной строки для SHELL?
              
   **Преимущества командной строки:**

Зачем возиться с командной строкой, если существуют удобные и красивые графические интерфейсы? Тому есть множество причин. 

Во-первых, далеко не все операции удобнее и быстрее выполнять с помощью графического интерфейса. 

Во-вторых, каждая программа следует основополагающему принципу Unix-систем: делать чётко определённую работу и делать её хорошо. 

В-третьих, осваивая команды, пробуя их сочетания и комбинации их параметров, пользователь изучает систему, приобретая ценный практический опыт.

Пользователь получает доступ к таким эффективным инструментам, как конвейеры, позволяющие организовать цепочку команд для обработки данных, средства перенаправления ввода/вывода, а кроме того, можете программировать непосредственно в командной оболочке.

## 2) Основной шаг

Что же, после того как мы узнали что такое shell и как он примерно работает, неплохо было бы также уметь его скачивать. Для есть одна замечательная команда, которую мы используем в терминале Linux. Но сперва тебе, дорогой пользователь, стоит убедиться, что ты хояешь установить папку с моим shell именно там, где ты хочешь. Так вот, вот наша замечательная команда:

    git clone https://github.com/LeoRaiderNL/shell

Просто скопируй ее и вставь в свой терминал. И про Enter не забудь, а то стыдно будет)

Стоит также сразу же скомпилировать этот shell, для этого достаточно будучи в папке shell ввести в терминал данную команду, не заходя в папку src: 

    make
    
После этой команды, в папке src появится скомпелированный код, которым можно будет пользоваться.

После завершения данной манипуляции, с облегчением в сердце, теперь можно рассмотреть возможности моего shell. 

## 3) СБОРКА СВОЕГО SHELL НА ЯЗЫКЕ СИ (С)

Разделим основные фитчи нашего SHELL на несколько важных деталей.

### 1) Деление на лексемы

Так как мы пользуемся командной строкой, то нам нужно уметь работать со строками. То есть дана строка - последоватльность слов, разделяемых пробельными символами (табуляции, пробелы).

Нам нужно описать функцию, которая будет считывать текст до пробела, табуляции или переноса строки. Она должна выделять память и возращать указатель на слово и на последний символ. С помощью этой функции, мы как раз и поделим строку на лексемы. Это функция:

    char get_word(...) {
        ...
    }

Так нам понадобится вторая функция, но она будет считывать весть текст до переноса строки, выделять память, и возращать указатель. Это функция:

    char get_list(...) {
        ...
    }

Так же нам желательно обзовестись дополнительной функцией, которая будет освобождать память, которую мы занимали под храниние строки. То есть, мы будем чистить память каждый раз, когда у нас будет переход на новую строку. Конечно, стоит заверить тебя, дорогой пользователь, что данная строка будет выполнена до ее чистки. Это функция:

    void delete_list(...) {
        ...
    }

### 2) Стандартный запуск программы

Теперь нужно обзовестись механизмом выхода из нашего ручного SHELL. А именно, мы будем в бесконечном цикле выполнять запуск программы до тех пор, пока не встретяться слова exit и quit. За это отвечает функция:

    int cmp_exit(...) {
        ...
    }

### 3) Перенаправление ввода и вывода

Если в качестве лексемы встречается символ перенаправления ввода или вывода в файл, то сделать соответствющий ввод или вывод в файл. Это делает наша функция:

    void io_file(...)  {
        ...
    }

### 4) Конвейер |

Данный конвейер позволяет нам вызывать несколько команд обработки текста друг за другом. У меня он обозначается, как:

    int conv1(...) {
        ...
    }

В данном конвейере кстати можно увидеть функцию swap_dir() (смотрим 5 пункт). Сам конвейер запускается в

    int additiobal_hall(...) {
        ...
    }


### 5) Смена директории cd

Почему бы нам теперь не обзовестись крутой возможностью - сменять директории и даже возращаться в нашу изначальную директорию всех директорий, то есть домашнюю директорию. За это отвечает данная функция:

    int swap_dir(...) {
        ...
    }

Вот пример команды для swap_dir():

    cd ~

Это команда просто вернет нас в домашнюю директорию.

### 6) Конвейер &&

Позволяет выполнять последовательно команды, причем каждая следующая команда выполняется только тогда, когда предыдуща была выполнена успешно:

    int conv2(...) {
        ...
    }

В данном конвейере кстати можно увидеть функцию swap_dir() (смотрим 5 пункт). Сам конвейер запускается в

    int additiobal_hall(...) {
        ...
    }


### 7) Ctrl + C

За реализацию CTRL + C в handler отвечает функция:

    void handler(...) {
        ...
    }

Как она работает? Мы работаем через сигналы. Когда мы используем сочетание клавищ CTRL + C, мы по сути отправляем сигнал, который убьет наш изначальный процесс и закончит программу.
